generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// User - Tabela de usuários do sistema
// ==========================================
model User {
  id           String    @id @default(uuid())
  email        String    @unique
  passwordHash String    @map("password_hash")
  displayName  String    @map("display_name")
  credits      Int       @default(10000)
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  // Relações
  purchases Purchase[]
  returns   Return[]

  @@index([email])
  @@index([displayName])
  @@map("users")
}

// ==========================================
// Cosmetic - Catálogo de cosméticos e bundles
// ==========================================
model Cosmetic {
  id         String   @id @default(uuid()) // ID interno
  externalId String   @unique @map("external_id") // ID externo da API do Fortnite
  name       String
  type       String   // Tipo dinâmico da API externa (outfit, pickaxe, glider, etc)
  rarity     String   // Raridade dinâmica da API externa (common, rare, epic, etc)
  imageUrl   String   @map("image_url")
  addedAt    DateTime @map("added_at") // Data que foi adicionado no Fortnite
  
  // Flags de estado
  isNew     Boolean  @default(false) @map("is_new")
  onSale    Boolean  @default(false) @map("on_sale")
  salePrice Int?     @map("sale_price") // Preço promocional quando onSale=true
  
  // Bundle info
  isBundle  Boolean  @default(false) @map("is_bundle")
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  purchases    Purchase[]
  returns      Return[]
  
  // Relações de bundle
  bundleItems  BundleItem[] @relation("Bundle")
  itemOfBundle BundleItem[] @relation("Item")

  @@index([name])
  @@index([type])
  @@index([rarity])
  @@index([addedAt(sort: Desc)])
  @@index([isNew])
  @@index([onSale])
  @@index([isBundle])
  @@index([type, rarity])
  @@index([onSale, salePrice])
  @@index([externalId])
  @@map("cosmetics")
}

// ==========================================
// BundleItem - Relação entre bundles e seus itens
// ==========================================
model BundleItem {
  id       String @id @default(uuid())
  bundleId String @map("bundle_id")
  itemId   String @map("item_id")
  
  // Relações
  bundle Cosmetic @relation("Bundle", fields: [bundleId], references: [id], onDelete: Cascade)
  item   Cosmetic @relation("Item", fields: [itemId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([bundleId, itemId])
  @@index([bundleId])
  @@index([itemId])
  @@map("bundle_items")
}

// ==========================================
// Purchase - Registro de compras
// ==========================================
model Purchase {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  cosmeticId String   @map("cosmetic_id")
  price      Int      // Preço efetivamente pago no momento da compra
  
  // Rastreabilidade de bundle
  isFromBundle     Boolean  @default(false) @map("is_from_bundle") // Se foi adquirido como parte de um bundle
  parentPurchaseId String?  @map("parent_purchase_id") // ID da compra do bundle pai (se aplicável)
  
  createdAt  DateTime @default(now()) @map("created_at")

  // Relações
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  cosmetic Cosmetic @relation(fields: [cosmeticId], references: [id], onDelete: Restrict)
  
  // Auto-relação para compras de bundle
  parentPurchase Purchase?  @relation("BundlePurchase", fields: [parentPurchaseId], references: [id], onDelete: Cascade)
  childPurchases Purchase[] @relation("BundlePurchase")

  @@unique([userId, cosmeticId]) // Garante que um usuário só pode comprar um item uma vez
  @@index([userId])
  @@index([cosmeticId])
  @@index([createdAt(sort: Desc)])
  @@index([parentPurchaseId])
  @@map("purchases")
}

// ==========================================
// Return - Registro de devoluções
// ==========================================
model Return {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  cosmeticId String   @map("cosmetic_id")
  refunded   Int      // Valor estornado (mesmo que foi pago)
  
  // Se foi devolução de bundle, registrar
  isBundle   Boolean  @default(false) @map("is_bundle")
  
  createdAt  DateTime @default(now()) @map("created_at")

  // Relações
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  cosmetic Cosmetic @relation(fields: [cosmeticId], references: [id], onDelete: Restrict)

  @@index([userId])
  @@index([cosmeticId])
  @@index([createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("returns")
}

// ==========================================
// SyncLog - Logs de sincronização com API externa
// ==========================================
model SyncLog {
  id        String   @id @default(uuid())
  job       String   // sync:cosmetics, sync:new, sync:shop
  status    String   // pending, running, success, failed
  message   String?  // Mensagem de erro ou sucesso
  
  // Métricas opcionais
  itemsProcessed Int?     @map("items_processed")
  itemsCreated   Int?     @map("items_created")
  itemsUpdated   Int?     @map("items_updated")
  duration       Int?     // Duração em ms
  
  startedAt  DateTime? @map("started_at")
  finishedAt DateTime? @map("finished_at")
  createdAt  DateTime  @default(now()) @map("created_at")

  @@index([job])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([job, status, createdAt(sort: Desc)])
  @@map("sync_logs")
}

// ==========================================
// IdempotencyKey - Para garantir idempotência em operações
// ==========================================
model IdempotencyKey {
  id        String   @id @default(uuid())
  key       String   @unique
  userId    String   @map("user_id")
  endpoint  String
  response  Json     // Resposta armazenada para reenvio
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([key])
  @@index([userId])
  @@index([expiresAt])
  @@map("idempotency_keys")
}