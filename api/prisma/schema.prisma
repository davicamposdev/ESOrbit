generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String   @map("password_hash")
  username     String   @map("username")
  credits      Int      @default(10000)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  purchases         Purchase[]
  returns           Return[]
  transfersSent     Transfer[] @relation("TransfersSent")
  transfersReceived Transfer[] @relation("TransfersReceived")

  @@index([email])
  @@index([username])
  @@map("users")
}

model Cosmetic {
  id           String   @id @default(uuid())
  externalId   String   @unique @map("external_id")
  name         String
  type         String
  rarity       String
  imageUrl     String   @map("image_url")
  addedAt      DateTime @map("added_at")
  isNew        Boolean  @default(false) @map("is_new")
  isAvailable  Boolean  @default(false) @map("is_available")
  basePrice    Int?     @map("base_price")
  currentPrice Int?     @map("current_price")
  onSale       Boolean  @default(false) @map("on_sale")
  isBundle     Boolean  @default(false) @map("is_bundle")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  purchases       Purchase[]
  returns         Return[]
  bundleCosmetics BundleCosmetic[]

  @@index([name])
  @@index([type])
  @@index([rarity])
  @@index([addedAt(sort: Desc)])
  @@index([isNew])
  @@index([isAvailable])
  @@index([onSale])
  @@index([isBundle])
  @@index([type, rarity])
  @@index([isAvailable, currentPrice])
  @@index([externalId])
  @@map("cosmetics")
}

model Bundle {
  id         String   @id @default(uuid())
  externalId String   @unique @map("external_id")
  name       String   @map("name")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  relation BundleCosmetic[]

  @@index([name])
  @@map("bundles")
}

model BundleCosmetic {
  id          String   @id @default(uuid())
  bundleId    String   @map("bundle_id")
  cosmeticId  String   @map("cosmetic_id")
  description String   @map("description")
  createdAt   DateTime @default(now()) @map("created_at")

  bundle   Bundle   @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  cosmetic Cosmetic @relation(fields: [cosmeticId], references: [id], onDelete: Cascade)

  @@unique([bundleId, cosmeticId])
  @@index([bundleId])
  @@index([cosmeticId])
  @@map("bundle_cosmetics")
}

model Purchase {
  id               String         @id @default(uuid())
  userId           String         @map("user_id")
  cosmeticId       String         @map("cosmetic_id")
  transactionId    String         @map("transaction_id")
  isFromBundle     Boolean        @default(false) @map("is_from_bundle")
  parentPurchaseId String?        @map("parent_purchase_id")
  status           PurchaseStatus @default(ACTIVE)
  returnedAt       DateTime?      @map("returned_at")
  createdAt        DateTime       @default(now()) @map("created_at")
  updatedAt        DateTime       @updatedAt @map("updated_at")

  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  cosmetic       Cosmetic    @relation(fields: [cosmeticId], references: [id], onDelete: Restrict)
  transaction    Transaction @relation(fields: [transactionId], references: [id], onDelete: Restrict)
  parentPurchase Purchase?   @relation("BundlePurchase", fields: [parentPurchaseId], references: [id], onDelete: Cascade)
  childPurchases Purchase[]  @relation("BundlePurchase")
  returns        Return[]

  @@unique([userId, cosmeticId])
  @@index([userId])
  @@index([cosmeticId])
  @@index([status])
  @@index([transactionId])
  @@map("purchases")
}

model Return {
  id            String       @id @default(uuid())
  purchaseId    String       @map("purchase_id")
  userId        String       @map("user_id")
  cosmeticId    String       @map("cosmetic_id")
  transactionId String       @unique @map("transaction_id")
  reason        String?
  isPartial     Boolean      @default(false) @map("is_partial")
  status        ReturnStatus @default(COMPLETED)
  createdAt     DateTime     @default(now()) @map("created_at")
  updatedAt     DateTime     @updatedAt @map("updated_at")

  purchase    Purchase    @relation(fields: [purchaseId], references: [id], onDelete: Restrict)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  cosmetic    Cosmetic    @relation(fields: [cosmeticId], references: [id], onDelete: Restrict)
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Restrict)

  @@index([userId])
  @@index([purchaseId])
  @@index([status])
  @@index([transactionId])
  @@map("returns")
}

model Transfer {
  id                String         @id @default(uuid())
  fromUserId        String         @map("from_user_id")
  toUserId          String         @map("to_user_id")
  fromTransactionId String         @unique @map("from_transaction_id")
  toTransactionId   String         @unique @map("to_transaction_id")
  status            TransferStatus @default(COMPLETED)
  description       String?
  createdAt         DateTime       @default(now()) @map("created_at")
  updatedAt         DateTime       @updatedAt @map("updated_at")

  fromUser User @relation("TransfersSent", fields: [fromUserId], references: [id], onDelete: Restrict)
  toUser   User @relation("TransfersReceived", fields: [toUserId], references: [id], onDelete: Restrict)

  @@index([fromUserId])
  @@index([toUserId])
  @@index([status])
  @@map("transfers")
}

model Transaction {
  id        String            @id @default(uuid())
  amount    Int
  currency  String
  method    String
  type      TransactionType
  status    TransactionStatus @default(PENDING)
  createdAt DateTime          @default(now()) @map("created_at")

  purchases Purchase[]
  returns   Return[]

  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([type])
  @@map("transactions")
}

model SyncLog {
  id             String    @id @default(uuid())
  job            String
  status         String
  message        String?
  itemsProcessed Int?      @map("items_processed")
  itemsCreated   Int?      @map("items_created")
  itemsUpdated   Int?      @map("items_updated")
  duration       Int?
  startedAt      DateTime? @map("started_at")
  finishedAt     DateTime? @map("finished_at")
  createdAt      DateTime  @default(now()) @map("created_at")

  @@index([job])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([job, status, createdAt(sort: Desc)])
  @@map("sync_logs")
}

enum TransactionType {
  PURCHASE   @map("purchase")
  REFUND     @map("refund")
  TRANSFER   @map("transfer")
  BONUS      @map("bonus")
  ADJUSTMENT @map("adjustment")
}

enum TransactionDirection {
  CREDIT @map("credit")
  DEBIT  @map("debit")
}

enum TransactionStatus {
  PENDING   @map("pending")
  COMPLETED @map("completed")
  FAILED    @map("failed")
}

enum PurchaseStatus {
  ACTIVE    @map("active")
  RETURNED  @map("returned")
  CANCELLED @map("cancelled")
}

enum ReturnStatus {
  PENDING   @map("pending")
  COMPLETED @map("completed")
  FAILED    @map("failed")
}

enum TransferStatus {
  PENDING   @map("pending")
  COMPLETED @map("completed")
  FAILED    @map("failed")
}
